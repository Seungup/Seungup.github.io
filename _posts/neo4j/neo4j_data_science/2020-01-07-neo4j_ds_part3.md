---
title: neo4j - data science - part 3
category: others
tags: database graphdb neo4j datascience machinelearning exploratory 
---

## Recommendations

- 본 챕터에서는 기본적인 데이터에 대한 이해를 바탕으로 추천 author 추천 엔진을 만들어봅니다. 즉, 현재 collaborator 중에서 잠재적인 collaborator를 찾아볼 수 있겠죠. 또한 각 author에게 적합한 paper도 추천해 봅니다.


## Collaborative Filtering

- [Collaborative Filtering](https://en.wikipedia.org/wiki/Collaborative_filtering)은 두 개체간의 유사성을 찾아주는 기본적인 탐색 방법입니다. 흔히들 예로 드는 것이, 쇼핑 목록이죠. 만약 A라는 사람이 상품 가, 나, 다, 라를 샀고, B라는 사람이 상품 가, 나, 다, 라 를 샀다면, 이 둘은 서로 어떤 취향이 유사하다, 라고 말해질 수 있습니다. 물론, 여기서, 그 유사도를 어떻게 측정할 것이냐?, 상품 구매유무만 볼 것인가, 상품에 대한 피드백도 볼 것인가(즉, 값이 binary냐, numerical이냐) 등에 따라서 그 유사도를 측정하는 방식이 많이 달라지기는 합니다. 
- 어쨌거나, 기본적으로는 각 사람에 대해서 profile을 설정하고 이 profile 간의 유사도를 측정하는 것이 가장 기본적인 계산법이 되는 셈이죠.

## Exercise 1: Coauthor Collaborative Filtering with Cypher

- 일단 환경설정을 합시다. 

```python
!pip install py2neo==4.1.3 pandas matplotlib sklearn
from py2neo import Graph
import pandas as pd

import matplotlib 
import matplotlib.pyplot as plt

plt.style.use('fivethirtyeight')
pd.set_option('display.float_format', lambda x: '%.3f' % x)
pd.set_option('display.max_colwidth', 100)

graph = Graph("bolt://18.207.236.58:35753", auth=("neo4j", "<password>"))
```

- 우선 authoring을 많이 한 저자를 찾아봅니다. 
- 사실, 이 러한 구문은 SQL에서는 group by 를 통해 더 간단하고 직관적으로 돌아가는데, 여기서는 group by 가 없으니까 약간 헷갈리는 느낌이 있는 것 같아요

```
popular_authors_query = """
MATCH (author:Author)<-[rel:AUTHOR]-()
RETURN author.name AS authorName, count(rel) AS articlesPublished
ORDER BY articlesPublished DESC
LIMIT 10
"""

for k_v in graph.run(popular_authors_query).data():
    print(k_v)
```

- 이제는 저자별로, 저자의 저작물과 각 저작물의 citation 횟수에 대해서 가져와 봅시다. 특이한 점은, 여기에서는 `parame`을 변수로 넘겨주어다는 점이죠. 

```python

# query안에 `$param` 을 선언하여, 이후에 쿼리를 실행할 때 값을 넘겨서 진행할 수 있도록 처리해줌
author_articles_query = """
MATCH (author:Author {name: $authorName})<-[:AUTHOR]-(article:Article)<-[cited:CITED]-()
RETURN article.title AS article, article.year AS year, count(cited) as citations
ORDER BY citations DESC, year DESC
LIMIT 20
"""

target_author_name = "Peter G. Neumann"
# query안에 정의된 $param을 아래와 같이 딕셔너리오 형태로 넘겨줌
query_result = graph.run(author_articles_query,  {"authorName": author_name})
for k_v in query_result.data():
    print(k_v)
```


```
{'article': 'The foresight saga, redux', 'year': 2012, 'citations': 2}
{'article': 'Security by obscurity', 'year': 2003, 'citations': 2}
{'article': 'Risks of automation: a cautionary total-system perspective of our cyberfuture', 'year': 2016, 'citations': 1}
{'article': 'The foresight saga', 'year': 2006, 'citations': 1}
{'article': 'Information system security redux', 'year': 2003, 'citations': 1}
{'article': 'Risks of National Identity Cards', 'year': 2001, 'citations': 1}
{'article': 'Robust open-source software', 'year': 1999, 'citations': 1}
{'article': 'Crypto policy perspectives', 'year': 1994, 'citations': 1}
{'article': 'Are dependable systems feasible', 'year': 1993, 'citations': 1}
{'article': 'Computers, ethics, and values', 'year': 1991, 'citations': 1}
```

- 이제 저자의 collaborator를 알아봅시다. 

```python
collaborations_query = """
MATCH (:Author {name: $authorName})<-[:AUTHOR]-(article:Article)-[:AUTHOR]->(coauthor:Author)
RETURN coauthor.name AS coauthor, count(*) AS collaborations
ORDER BY collaborations DESC
LIMIT 10
"""

target_author_name = "Peter G. Neumann"
target_author_name = "Brian Fitzgerald"

query_result_df = graph.run(collaborations_query,  {"authorName": target_author_name}).to_data_frame()
print(query_result_df)
```

```
           coauthor  collaborations
0    Klaas-Jan Stol               6
1     Joseph Feller               5
2   Scott A. Hissam               4
3  Karim R. Lakhani               3
4      Walt Scacchi               2
5     Donal O'Brien               1
6     Björn Lundell               1
7     Martin Krafft               1
8       Brian Lings               1
9  Andrea Capiluppi               1
```

- 그 다음으로는 co-author의 co-author를 찾습니다. 사실, 원래의 쿼리는 다음과 같아요. 

```
MATCH (author:Author {name: $authorName})<-[:AUTHOR]-(article)-[:AUTHOR]->(coauthor),
      (coauthor)<-[:AUTHOR]-()-[:AUTHOR]->(coc)
WHERE not((coc)<-[:AUTHOR]-()-[:AUTHOR]->(author)) AND coc <> author      
RETURN coc.name AS coauthor, count(*) AS collaborations
ORDER BY collaborations DESC
LIMIT 10
```

- 다만, 저는 약간 full-join과 비슷하게 진행했습니다. 이렇게 하면, 사실 graphDB의 이점을 살리지 못하고, 한 단계 한단계씩 뻗어나가는 형태가 되기는 하는데, 그래도 저는 약간은, 이게 더 편한 것 같기도 해요. 
- 즉, node-edge의 관계를 기반으로 하나씩 하나씩 연결하는 식으로 처리했습니다.

```
MATCH (target_author:Author {name: $authorName})<-[:AUTHOR]-(article1:Article), 
      (article2:Article)-[:AUTHOR]->(coauthor1:Author), //first author to author
      (coauthor2:Author)<-[:AUTHOR]-(article3:Article), 
      (article4:Article)-[:AUTHOR]->(cocoauthor:Author) //second author to author
WHERE (article1=article2) 
      AND (coauthor1=coauthor2)
      AND (article3=article4)
      AND NOT (target_author=coauthor1)
      AND NOT (target_author=cocoauthor)
      AND NOT ((target_author)<-[:AUTHOR]-()-[:AUTHOR]->(cocoauthor))
RETURN cocoauthor.name, count(*) AS COLLABORATIONS
ORDER BY COLLABORATIONS DESC
LIMIT 20
```

## Exercise 2: Recommendations

- 여기서는 PageRank라는, 구글의 서치엔진 알고리즘을 기반으로 네트워크의 연결성, 영향력(transitive influence, connectivity)을 측정하는 알고리즘을 사용해봅니다. 
- GraphDB는 기본적으로는 데이터를 Graph의 형식으로 저장하는 것을 목적으로 하지만, 기본적인 Graph Algorithm은 저장하고 있습니다. 그 중 하나가, PageRank이며, 이는 랜덤으로 그래프의 방향에 따라 돌아다니면서, 그래프에 영향력을 크게 줄 수 있는 노드를 계산하는 방법이죠. 
- 특히, Citation Network에서는 방향성이 있기 때문에, 그 영향력, 다시 말하면, "많이 인용되는 논문을 중요하게 고려"하는 것과 같은 방법들이 가능해지죠. 간단하게 아래와 같이 실행하면 됩니다. 해당되는 `node label`과, `relationship type` 그리고 `config`을 딕셔너리로 넘겨주면 되죠.

```
CALL algo.pageRank(<node label>, <relationship type>, <config>)
CALL algo.pageRank('Article', 'CITED', {iterations:20, dampingFactor:0.85, concurrency:4})
```

```python
# basic pagerank
# 아래와 같이 algorithm을 실행하게 되면, 각 노드에 그 결과 값이 property로 들어가있게 된다.
query = """
CALL algo.pageRank('Article', 'CITED')
"""
query_result = graph.run(query).data()
print(query_result)
print("--"*30)
query = """
MATCH (ar:Article)
RETURN ar.title AS TITLE, ar.pagerank AS NODE_PG
LIMIT 5
"""

query_result_df = graph.run(query).to_data_frame()
print(query_result_df)
```


- 다만, 위와 같이 실행하게 되면, 해당 pagerank 값이 바로 각 node의 property로 들어가게 됩니다. 따라서, 값을 저장하지 않고, 바로 전달받고 싶다면 다음처럼 실행하는 것이 좋아요. 
    - `algo.pageRank.stream`을 통해서 값들을 저장하지 않고, 바로 읽어들이고, 
    - 이를 `YIELD`를 사용하여, 필요한 값을 남깁니다. 
    - 그리고, `RETURN`을 통해 출력하는 식으로 진행되죠.

```
CALL algo.pageRank.stream('Page', 'LINKS', {iterations:20, dampingFactor:0.85})
YIELD nodeId, score
RETURN nodeId, score
LIMIT 10 
```

### Personalized PageRank

- 전체 노드에 대해서 pagerank 알고리즘을 계산하지 않고, 필요한 중요한 노드만 선별한 다음 계산하는 것 또한 가능합니다. 가령, 특정 연도, 특정 저자 등에 대해서 처리할 수 있겠죠. 이처럼, 특정한 node들에 대해서만 처리해주기 위해서는, `algo.pageRank.stream('Page', 'LINKS', {sourceNodes: sourceNodes})`처럼, `sourceNodes`에 대한 정보를 config에 넘겨주면 됩니다.
- 우선 그렇다면 `sourceNode`를 가져와 봅시다. 다음의 형식으로 가져오며, 의도는 우리가 이미 정의한 `author`가 쓴 논문과 이 논문을 1차적으로 인용한 논문들만을 가져옵니다.

```
MATCH (a:Author {name: $author})<-[:AUTHOR]-(article)-[:CITED]->(other)
WITH collect(article) + collect(other) AS sourceNodes
RETURN sourceNodes
```

- 그리고, 가져온 sourceNode를 config으로 넘겨주고, 다음처럼 실행합니다. 아래의 쿼리는 순서가 다음과 같습니다.
    - `MATCH`: 적합한 노드를 검색합니다 
    - `WITH` + `collect`: 필요한 노드를 집합으로 합쳐서, `sourceNodes`라는 변수에 저장해줍니다.
    - `CALL algo.pageRank.stream`에 config으로 `sourceNodes`을 넘겨주고, 대상으로 하는 label(Article)과, relationship(CITED)을 함께 넘겨줍니다. 
    - 그렇게 생긴 `nodeId`, `score`를 남기고, 
    - 다만, 지금은 nodeId만 있습니다. 이 아이는 primary_key인데, id로 노드를 반환해주는 `algo.getNodeById`를 통해서, node를 반환받죠. 
    - 이제 그다음 필요한 요소들을 `RETURN`을 통해서 전달합니다.

```python
query = """
MATCH (a:Author {name: $author})<-[:AUTHOR]-(article)-[:CITED]->(other)
WITH collect(article) + collect(other) AS sourceNodes
CALL algo.pageRank.stream('Article', 'CITED', {sourceNodes: sourceNodes})
YIELD nodeId, score
WITH algo.getNodeById(nodeId) as node, score
RETURN node.title AS article_title, score
ORDER BY score DESC
LIMIT 10
"""

## personalized pagerank
author_name = "Peter G. Neumann"
query_result = graph.run(query, {"author": author_name}).data()
for n in query_result:
    print(n)
print(query_result)
```

- 코드 실행 결과는 대략 다음과 같습니다.

```
{'article': 'A technique for software module specification with examples', 'score': 0.3585283908905801}
{'article': 'A messy state of the union: taming the composite state machines of TLS', 'score': 0.33168750405311587}
{'article': 'Crypto policy perspectives', 'score': 0.27750000506639483}
{'article': 'Risks of automation: a cautionary total-system perspective of our cyberfuture', 'score': 0.27750000506639483}
{'article': 'The foresight saga', 'score': 0.27750000506639483}
{'article': 'Risks of e-voting', 'score': 0.27750000506639483}
```

## Topic Sensitive Search

You can also use Personalized PageRank to do 'Topic Specific PageRank'. 

When an author is searching for articles to read, they want that search to take themselves as authors into account. Two authors using the same search term would expect to see different results depending on their area of research.

Create a full text search index on the 'title' and 'abstract' properties of all nodes that have the label 'Article' by executing this code:

## wrap-up

- 